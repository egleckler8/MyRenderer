// Yeah...
        // ************************************************
        // Set up some stuff for the triangle
        // ************************************************


        // Vertex buffer object
        // Remember, OpenGL is doing stuff behind the scenes!
        // We only need the address of the object to do stuff to it

        // From this point on...
        //glBindBuffer(GL_ARRAY_BUFFER, VBO);
        // ... any buffer calls we make (on the GL_ARRAY_BUFFER target) will
        // be used to configure the currently bound buffer, which is VBO. Then
        // we can make a call to the glBufferData function that copies the
        // previously defined vertex data into the bufferâ€™s memory:
        //glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
        // That is saying that we want to...
        // Copy sizeof(vertices) bytes out of vertices into the GL_ARRAY_BUFFER
        // then we tell the GPU that the data won't change (static) when we draw it many times

        // We could use GL_DYNAMIC_DRAW if we knew vertices would be changing
        // often and wanted the GPU to put the memory in a place that allows faster writes...
        // heheh





        // We've sent the vertex data to memory in the VBO
        // and created a shader program to process the vertex data
        // but we need to tell OpenGL how to interpret the vertex data
        // and link it to the shader program for processing

        // just observe the data structure of the vertices

        //glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),
                              //(void*)0);
        /*
         * 1. First param specificies which vertex attribute we want to configure
         * 2. Next is size of the vertex attribute in #values, which is 3 for vec3
         * 3. type of data in each vertex attribute slot
         * 4. ???
         * 5. space between consecutive vertex attributes, simply size * sizeof data type inside
         * 6. offset of where the position data begins in the buffer, which is just 0 for us.
         *    We'll explore this more later on??
         */
        //glEnableVertexAttribArray(0);

        /*
         * Get a load of this...::
         *
         * "Each vertex attribute takes its data from memory managed by a VBO and
         * which VBO it takes its data from (you can have multiple VBOs) is determined
         * by the VBO currently bound to GL_ARRAY_BUFFER when calling glVertexAttribPointer.
         * Since the previously defined VBO is still bound before calling glVertexAttribPointer
         * vertex attribute 0 is now associated with its vertex data."
         *
         * So, this is the linking of the attributes (pos, color, texture, normal vec, etc)
         *
         * Ok so... my understanding is this:
         * Before doing the rendering loop, create your VBO representing an object
         * Then, create your shaders
         * NExt, .., create VAO for each VBO and bind all the vertex attribute pointers
         * to it, respectively. Then, instead of separetly binding EVERY
         * vertex attribute pointer to EVERY vertex in the vertex buffer then rendering EVERY loop,
         * we can do it once at the beginning, then the VAO will quickly chase the pointers
         * during runtime instead of us binding memory locations super often
         */


        // Ok, let's bind it!
        //glBindVertexArray(VAO);
        // copy our vertices array into a buffer for OpenGL to use
        //glBindBuffer(GL_ARRAY_BUFFER, VBO);
        //glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
        // then, bind the vertex attribute pointers to the VAO
        //glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        //glEnableVertexAttribArray(0);